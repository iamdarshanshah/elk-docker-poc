input {
  http_poller {
    urls => {
      test2 => {
        # Supports all options supported by ruby's Manticore HTTP client
        method => get
        url => "http://172.23.234.49:8000/internal/api/v1/timelinerecorder/trainingParticipations?limit=1000"
        headers => {
          Accept => "application/json"
          authorization => "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkb21haW4iOiJodHRwczovL2hvYmJlcy1kZXYuc3RhY2tyb3V0ZS5pbiIsInNlY3JldCI6IjAyYTIyYTU4LWMwYWQtNDkyZi05MmJhLWNhMzE2YWJlNTc1MCIsImVtYWlsIjoiZGFyc2hhbi5zaGFoQHN0YWNrcm91dGUuaW4iLCJpYXQiOjE1ODA0NTQyODcsImV4cCI6MTU5NjIzMjc4NywiaXNzIjoiU3RhY2tSb3V0ZS1LcmFtYSIsInN1YiI6InVzZXIifQ.h3m6O1SSIBvugaGtUhChwWIWjj8uuwKuYDMMXNzOGW4"
          cld => "https://hobbes-dev.stackroute.in"
          cls => "02a22a58-c0ad-492f-92ba-ca316abe5750"
        }
      }
      test3 => {
        # Supports all options supported by ruby's Manticore HTTP client
        method => get
        url => "http://172.23.234.49:8000/internal/api/v1/timelinerecorder/trainingParticipations?limit=1000&page=20"
        headers => {
          Accept => "application/json"
          authorization => "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkb21haW4iOiJodHRwczovL2hvYmJlcy1kZXYuc3RhY2tyb3V0ZS5pbiIsInNlY3JldCI6IjAyYTIyYTU4LWMwYWQtNDkyZi05MmJhLWNhMzE2YWJlNTc1MCIsImVtYWlsIjoiZGFyc2hhbi5zaGFoQHN0YWNrcm91dGUuaW4iLCJpYXQiOjE1ODA0NTQyODcsImV4cCI6MTU5NjIzMjc4NywiaXNzIjoiU3RhY2tSb3V0ZS1LcmFtYSIsInN1YiI6InVzZXIifQ.h3m6O1SSIBvugaGtUhChwWIWjj8uuwKuYDMMXNzOGW4"
          cld => "https://hobbes-dev.stackroute.in"
          cls => "02a22a58-c0ad-492f-92ba-ca316abe5750"
        }
      }
    }
    request_timeout => 60
    # Supports "cron", "every", "at" and "in" schedules by rufus scheduler
    schedule => { "in" => "0" }
    codec => "json"
    # A hash of request metadata info (timing, response headers, etc.) will be sent here
    # metadata_target => "http_poller_metadata"
  }
}

filter {
  prune {
    whitelist_names => ["result"]
  }
  # json {
  #   source => message
  #   target => data
  # }
  split {
    field => result
  }
  date {
    match => ["[result][logEntryTS]" , "yyyy-MM-dd'T'HH:mm:ss.SSSZ"]
    target => "@timestamp"
  }
}

output {
  stdout {  }
  elasticsearch {
		hosts => "elasticsearch:9200"
		user => "elastic"
		password => "changeme"  
    index => timeline_recorder
    action => index
	}
}